# 内置工具

<cite>
**本文档引用的文件**   
- [grep_chunks.go](file://internal/agent/tools/grep_chunks.go)
- [knowledge_search.go](file://internal/agent/tools/knowledge_search.go)
- [list_knowledge_chunks.go](file://internal/agent/tools/list_knowledge_chunks.go)
- [web_search.go](file://internal/agent/tools/web_search.go)
- [web_fetch.go](file://internal/agent/tools/web_fetch.go)
- [todo_write.go](file://internal/agent/tools/todo_write.go)
- [get_document_info.go](file://internal/agent/tools/get_document_info.go)
- [query_knowledge_graph.go](file://internal/agent/tools/query_knowledge_graph.go)
- [database_query.go](file://internal/agent/tools/database_query.go)
- [sequentialthinking.go](file://internal/agent/tools/sequentialthinking.go)
- [registry.go](file://internal/agent/tools/registry.go)
- [tool.go](file://internal/agent/tools/tool.go)
- [definitions.go](file://internal/agent/tools/definitions.go)
</cite>

## 目录
1. [引言](#引言)
2. [检索工具](#检索工具)
3. [深度阅读工具](#深度阅读工具)
4. [网络搜索工具](#网络搜索工具)
5. [研究计划工具](#研究计划工具)
6. [文档元数据工具](#文档元数据工具)
7. [知识图谱与数据库工具](#知识图谱与数据库工具)
8. [思考工具](#思考工具)
9. [工具注册与发现](#工具注册与发现)

## 引言
WeKnora系统提供了一套完整的内置工具集，用于支持智能代理的复杂任务执行。这些工具涵盖了从信息检索、内容获取到计划制定和数据分析的各个方面。本技术文档将深入分析每个工具的实现细节、调用关系和使用场景，为开发者和用户提供全面的技术参考。

## 检索工具

### grep_chunks.go
`grep_chunks`工具实现了类似Unix系统中grep命令的文本模式匹配功能，专门用于在知识库分块中进行精确的关键词搜索。该工具执行严格的字面文本匹配（固定字符串搜索），不进行语义搜索。

**参数解析**
- `pattern`（必需）：要搜索的文本模式，可以是单个或多个模式。作为字面文本处理（固定字符串匹配），结果匹配任何模式（OR逻辑）。
- `knowledge_base_ids`：按知识库ID过滤。如果为空，则搜索所有允许的知识库。
- `max_results`：返回匹配分块的最大数量（默认：50，最大：200）。

**查询构建**
工具通过构建数据库查询来执行模式匹配，支持多个模式的OR逻辑。查询使用不区分大小写的ILIKE操作符进行匹配。对于单个模式，直接使用`WHERE chunks.content ILIKE ?`；对于多个模式，则使用`OR`连接多个条件。

**结果去重（MMR）策略**
该工具实现了最大边际相关性（Maximal Marginal Relevance, MMR）算法来减少冗余并提高结果多样性。MMR通过平衡相关性和多样性来选择结果：
- 当结果数量超过10个时，应用MMR算法
- 使用Jaccard相似度计算文本块之间的冗余度
- MMR得分计算公式：`lambda*relevance - (1-lambda)*redundancy`，其中lambda=0.7
- 通过贪心算法迭代选择最优结果

工具还实现了基于内容签名的去重机制，通过`buildContentSignature`函数创建内容的规范化签名来检测近似重复的内容。

**Section sources**
- [grep_chunks.go](file://internal/agent/tools/grep_chunks.go#L1-L694)

### knowledge_search.go
`knowledge_search`工具提供了基于语义/向量的搜索功能，通过嵌入（embeddings）理解用户查询并查找知识库分块中的语义相关内容。

**参数解析**
- `queries`（必需）：1-5个语义问题或概念性陈述，应反映要检索的含义或主题。
- `knowledge_base_ids`（可选）：限制搜索范围的知识库ID。

**查询构建**
工具执行并发混合搜索（hybrid search），同时处理向量和关键词搜索。搜索参数从租户会话配置中获取，包括：
- `topK`：返回的前K个结果
- `vectorThreshold`：向量相似度阈值
- `keywordThreshold`：关键词相似度阈值

**结果去重（MMR）策略**
与`grep_chunks`类似，该工具也应用了MMR算法来减少冗余：
- 在重排序后应用MMR，输入为重排序后的结果
- k值根据`topK`参数和结果数量确定
- 使用lambda=0.7平衡相关性和多样性
- 预计算所有候选结果的token集合以提高效率

工具还实现了两级重排序机制：优先使用LLM进行重排序，如果不可用则使用rerank模型。重排序后应用MMR以确保结果的多样性和相关性。

**Section sources**
- [knowledge_search.go](file://internal/agent/tools/knowledge_search.go#L1-L1323)

## 深度阅读工具

### list_knowledge_chunks.go
`list_knowledge_chunks`工具是"深度阅读"的核心工具，用于按知识文档ID检索分块快照。该工具在获取完整文本内容中具有强制性作用，是连接检索结果和完整内容的关键桥梁。

**重要性**
该工具的重要性体现在：
1. **内容完整性**：在`grep_chunks`或`knowledge_search`找到相关文档后，必须使用此工具获取文档的完整内容。
2. **上下文查看**：允许查看特定分块周围的上下文，理解内容的完整语境。
3. **文档结构分析**：可以检查文档的分块数量和结构，了解文档的组织方式。

**参数解析**
- `knowledge_id`（必需）：要检索分块的文档ID
- `limit`（可选）：每页的分块数量（默认20，最大100）
- `offset`（可选）：起始位置（默认0）

**使用流程**
典型的使用流程为：
1. 使用`grep_chunks(["keyword", "变体"])`获取`knowledge_id`
2. 调用`list_knowledge_chunks(knowledge_id)`读取完整内容

该工具返回完整的分块内容，包括`chunk_id`、`chunk_index`和`content`文本，为后续的深度分析提供基础。

**Section sources**
- [list_knowledge_chunks.go](file://internal/agent/tools/list_knowledge_chunks.go#L1-L240)

## 网络搜索工具

### web_search.go 和 web_fetch.go
`web_search.go`和`web_fetch.go`构成了网络搜索的协作关系，分别负责摘要获取和完整内容提取。

**web_search.go**
`web_search`工具执行网络搜索并返回结果摘要，主要功能包括：
- 实时网络搜索：查找知识库中可能不存在的最新信息
- RAG压缩：自动压缩和提取搜索结果中的相关内容
- 会话级缓存：维护临时知识库以避免重复索引

**使用规则**
- 必须先完成知识库检索（`grep_chunks`和`knowledge_search`）
- 仅在知识库检索结果不足或无结果时使用
- 搜索结果包含URL、标题、摘要和内容片段（可能被截断）

**web_fetch.go**
`web_fetch`工具用于获取`web_search`发现的URL的完整网页内容，其协作关系如下：
- `web_search`返回摘要和URL
- `web_fetch`接收URL和提示词，获取完整页面内容
- 使用LLM分析和总结网页内容

**协作流程**
1. `web_search`返回结果，但内容可能被截断（显示前500个字符）
2. 从结果中提取URL，使用`web_fetch`获取完整页面内容
3. `web_fetch`使用提示词调用小模型进行分析和总结
4. 返回总结结果和原始内容片段

这种分工确保了高效的信息获取：`web_search`快速获取摘要，而`web_fetch`在需要时获取完整内容。

**Section sources**
- [web_search.go](file://internal/agent/tools/web_search.go#L1-L280)
- [web_fetch.go](file://internal/agent/tools/web_fetch.go#L1-L602)

## 研究计划工具

### todo_write.go
`todo_write`工具用于创建和管理多步骤研究计划，帮助组织复杂的检索任务。

**功能**
该工具的主要功能包括：
- 创建结构化的任务列表
- 跟踪研究任务的进度
- 展示对用户的细致关注

**参数解析**
- `task`：需要创建计划的复杂任务或问题
- `steps`：包含状态跟踪的研究计划步骤数组
  - `id`：步骤的唯一标识符
  - `description`：步骤的描述
  - `status`：当前状态（pending, in_progress, completed）

**使用场景**
应在以下场景使用此工具：
1. 复杂的多步骤任务（需要3个或更多独立步骤）
2. 非平凡的复杂任务
3. 用户明确要求待办列表
4. 用户提供多个任务
5. 开始工作前立即捕获用户需求

**任务管理**
- 更新任务状态以实时跟踪进度
- 一次只将一个任务标记为`in_progress`
- 在开始新任务前完成当前任务
- 仅在完全完成任务后标记为`completed`

**Section sources**
- [todo_write.go](file://internal/agent/tools/todo_write.go#L1-L361)

## 文档元数据工具

### get_document_info.go
`get_document_info`工具用于提供文档的元数据信息，帮助理解文档的基本属性和状态。

**功能**
该工具的主要功能包括：
- 检索文档的详细元数据信息
- 批量查询多个文档的元数据
- 并发处理以提高性能

**参数解析**
- `knowledge_ids`（必需）：文档/知识ID数组，支持并发批量查询

**返回信息**
工具返回以下信息：
- 基本信息：标题、描述、来源类型
- 文件信息：文件名、类型、大小
- 处理状态：是否已处理、分块数量
- 元数据：自定义标签和属性

**使用建议**
- 当需要了解文档基本信息时使用
- 检查文档是否存在和可用性
- 批量查询多个文档的元数据
- 不用于获取文档内容（应使用`knowledge_search`）

该工具通过并发查询多个文档ID，提供了高效的元数据检索能力。

**Section sources**
- [get_document_info.go](file://internal/agent/tools/get_document_info.go#L1-L308)

## 知识图谱与数据库工具

### query_knowledge_graph.go
`query_knowledge_graph`工具用于查询知识图谱，探索实体之间的关系和知识网络。

**功能**
该工具的主要功能包括：
- 探索知识库中实体之间的关系
- 查询知识网络和概念关联
- 查找特定实体的相关信息

**参数解析**
- `knowledge_base_ids`（必需）：要查询的知识库ID数组（1-10个）
- `query`（必需）：查询内容，可以是实体名称或关系查询

**使用场景**
- 理解实体间的关系（如"Docker和Kubernetes之间的关系"）
- 探索知识网络和概念关联
- 查找特定实体的相关信息
- 理解技术架构和系统关系

**图谱配置**
知识图谱必须预先在知识库中配置：
- 实体类型（节点）：如"技术"、"工具"、"概念"
- 关系类型（关系）：如"依赖于"、"使用"、"包含"

**Section sources**
- [query_knowledge_graph.go](file://internal/agent/tools/query_knowledge_graph.go#L1-L404)

### database_query.go
`database_query`工具用于执行安全的SQL查询，从数据库中检索信息。

**安全特性**
- 自动注入`tenant_id`：所有查询自动按登录用户的`tenant_id`过滤
- 只读查询：仅允许SELECT语句
- 安全表：仅允许查询授权的表

**可用表**
- `knowledge_bases`：知识库信息
- `knowledges`（文档）：文档信息
- `chunks`：分块信息

**查询构建**
工具验证并保护SQL查询：
1. 检查是否为SELECT语句
2. 检测危险关键字（如DROP、DELETE等）
3. 验证表名是否在允许列表中
4. 自动注入`tenant_id`条件

**使用示例**
```json
{
  "sql": "SELECT id, name, description FROM knowledge_bases ORDER BY created_at DESC LIMIT 10"
}
```

**Section sources**
- [database_query.go](file://internal/agent/tools/database_query.go#L1-L427)

## 思考工具

### sequentialthinking.go
`sequentialthinking`工具用于进行顺序化思考，帮助分析复杂问题。

**功能**
该工具的主要功能包括：
- 将复杂问题分解为步骤
- 规划和设计时允许修订
- 分析可能需要路线修正的问题
- 处理初始范围不明确的问题

**参数解析**
- `thought`：当前的思考步骤
- `nextThoughtNeeded`：是否需要更多思考
- `thoughtNumber`：当前思考序号
- `totalThoughts`：预计需要的总思考数
- `isRevision`：是否修订之前的思考
- `revisesThought`：修订的思考序号
- `branchFromThought`：分支的思考序号
- `branchId`：分支标识符

**使用最佳实践**
1. 开始时估计需要的思考数，但准备调整
2. 自由质疑或修订之前的思考
3. 即使看似结束，也不要犹豫添加更多思考
4. 表达不确定性
5. 标记修订之前思考或分支到新路径的思考

**Section sources**
- [sequentialthinking.go](file://internal/agent/tools/sequentialthinking.go#L1-L311)

## 工具注册与发现

### registry.go
`registry.go`文件实现了工具的注册和发现机制，是工具系统的核心组件。

**功能**
`ToolRegistry`结构体管理工具的注册和检索：
- `RegisterTool`：将工具添加到注册表
- `GetTool`：按名称检索工具
- `ListTools`：返回所有注册工具的名称
- `GetFunctionDefinitions`：返回所有注册工具的函数定义
- `ExecuteTool`：按名称执行工具

**实现细节**
- 使用映射（map）存储工具，键为工具名称，值为工具实例
- 提供类型安全的工具接口，所有工具必须实现`Tool`接口
- 支持并发安全的工具执行

**工具接口**
所有工具必须实现`Tool`接口，包括：
- `Name()`：返回工具的唯一标识符
- `Description()`：返回工具的人类可读描述
- `Parameters()`：返回工具参数的JSON Schema
- `Execute()`：使用给定参数运行工具

**工具发现**
通过`GetFunctionDefinitions`方法，系统可以获取所有注册工具的定义，用于LLM函数调用。这使得LLM能够"发现"可用的工具并选择适当的工具来执行任务。

**Section sources**
- [registry.go](file://internal/agent/tools/registry.go#L1-L115)
- [tool.go](file://internal/agent/tools/tool.go#L1-L78)
- [definitions.go](file://internal/agent/tools/definitions.go#L1-L38)